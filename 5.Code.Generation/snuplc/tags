!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AddArg	src/ast.cpp	/^void CAstFunctionCall::AddArg(CAstExpression *arg)$/;"	f	class:CAstFunctionCall
AddChild	src/ast.cpp	/^void CAstScope::AddChild(CAstScope *child)$/;"	f	class:CAstScope
AddIndex	src/ast.cpp	/^void CAstArrayDesignator::AddIndex(CAstExpression *idx)$/;"	f	class:CAstArrayDesignator
AddInstr	src/ir.cpp	/^CTacInstr* CCodeBlock::AddInstr(CTacInstr *instr)$/;"	f	class:CCodeBlock
AddParam	src/symtab.cpp	/^void CSymProc::AddParam(CSymParam *param)$/;"	f	class:CSymProc
AddReference	src/ir.cpp	/^int CTacLabel::AddReference(int ofs)$/;"	f	class:CTacLabel
AddSymbol	src/symtab.cpp	/^bool CSymtab::AddSymbol(CSymbol *s)$/;"	f	class:CSymtab
BACKEND	Makefile	/^BACKEND=backend.cpp$/;"	m
CArrayType	src/type.cpp	/^CArrayType::CArrayType(int nelem, const CType *innertype)$/;"	f	class:CArrayType
CArrayType	src/type.h	/^class CArrayType : public CType {$/;"	c
CAstArrayDesignator	src/ast.cpp	/^	CAstArrayDesignator::CAstArrayDesignator(CToken t, const CSymbol *symbol)$/;"	f	class:CAstArrayDesignator
CAstArrayDesignator	src/ast.h	/^class CAstArrayDesignator : public CAstDesignator {$/;"	c
CAstBinaryOp	src/ast.cpp	/^CAstBinaryOp::CAstBinaryOp(CToken t, EOperation oper,$/;"	f	class:CAstBinaryOp
CAstBinaryOp	src/ast.h	/^class CAstBinaryOp : public CAstOperation {$/;"	c
CAstConstant	src/ast.cpp	/^	CAstConstant::CAstConstant(CToken t, const CType *type, long long value)$/;"	f	class:CAstConstant
CAstConstant	src/ast.h	/^class CAstConstant : public CAstOperand {$/;"	c
CAstDesignator	src/ast.cpp	/^	CAstDesignator::CAstDesignator(CToken t, const CSymbol *symbol)$/;"	f	class:CAstDesignator
CAstDesignator	src/ast.h	/^class CAstDesignator : public CAstOperand {$/;"	c
CAstExpression	src/ast.cpp	/^	CAstExpression::CAstExpression(CToken t)$/;"	f	class:CAstExpression
CAstExpression	src/ast.h	/^class CAstExpression : public CAstNode {$/;"	c
CAstFunctionCall	src/ast.cpp	/^	CAstFunctionCall::CAstFunctionCall(CToken t, const CSymProc *symbol)$/;"	f	class:CAstFunctionCall
CAstFunctionCall	src/ast.h	/^class CAstFunctionCall : public CAstExpression {$/;"	c
CAstModule	src/ast.cpp	/^	CAstModule::CAstModule(CToken t, const string name)$/;"	f	class:CAstModule
CAstModule	src/ast.h	/^class CAstModule : public CAstScope {$/;"	c
CAstNode	src/ast.cpp	/^	CAstNode::CAstNode(CToken token)$/;"	f	class:CAstNode
CAstNode	src/ast.h	/^class CAstNode {$/;"	c
CAstOperand	src/ast.cpp	/^	CAstOperand::CAstOperand(CToken t)$/;"	f	class:CAstOperand
CAstOperand	src/ast.h	/^class CAstOperand : public CAstExpression {$/;"	c
CAstOperation	src/ast.cpp	/^	CAstOperation::CAstOperation(CToken t, EOperation oper)$/;"	f	class:CAstOperation
CAstOperation	src/ast.h	/^class CAstOperation : public CAstExpression {$/;"	c
CAstProcedure	src/ast.cpp	/^CAstProcedure::CAstProcedure(CToken t, const string name,$/;"	f	class:CAstProcedure
CAstProcedure	src/ast.h	/^class CAstProcedure : public CAstScope {$/;"	c
CAstScope	src/ast.cpp	/^	CAstScope::CAstScope(CToken t, const string name, CAstScope *parent)$/;"	f	class:CAstScope
CAstScope	src/ast.h	/^class CAstScope : public CAstNode {$/;"	c
CAstSpecialOp	src/ast.cpp	/^CAstSpecialOp::CAstSpecialOp(CToken t, EOperation oper, CAstExpression *e,$/;"	f	class:CAstSpecialOp
CAstSpecialOp	src/ast.h	/^class CAstSpecialOp : public CAstOperation {$/;"	c
CAstStatAssign	src/ast.cpp	/^CAstStatAssign::CAstStatAssign(CToken t,$/;"	f	class:CAstStatAssign
CAstStatAssign	src/ast.h	/^class CAstStatAssign : public CAstStatement {$/;"	c
CAstStatCall	src/ast.cpp	/^	CAstStatCall::CAstStatCall(CToken t, CAstFunctionCall *call)$/;"	f	class:CAstStatCall
CAstStatCall	src/ast.h	/^class CAstStatCall : public CAstStatement {$/;"	c
CAstStatIf	src/ast.cpp	/^CAstStatIf::CAstStatIf(CToken t, CAstExpression *cond,$/;"	f	class:CAstStatIf
CAstStatIf	src/ast.h	/^class CAstStatIf : public CAstStatement {$/;"	c
CAstStatReturn	src/ast.cpp	/^	CAstStatReturn::CAstStatReturn(CToken t, CAstScope *scope, CAstExpression *expr)$/;"	f	class:CAstStatReturn
CAstStatReturn	src/ast.h	/^class CAstStatReturn : public CAstStatement {$/;"	c
CAstStatWhile	src/ast.cpp	/^CAstStatWhile::CAstStatWhile(CToken t,$/;"	f	class:CAstStatWhile
CAstStatWhile	src/ast.h	/^class CAstStatWhile : public CAstStatement {$/;"	c
CAstStatement	src/ast.cpp	/^	CAstStatement::CAstStatement(CToken token)$/;"	f	class:CAstStatement
CAstStatement	src/ast.h	/^class CAstStatement : public CAstNode {$/;"	c
CAstStringConstant	src/ast.cpp	/^CAstStringConstant::CAstStringConstant(CToken t, const string value,$/;"	f	class:CAstStringConstant
CAstStringConstant	src/ast.h	/^class CAstStringConstant : public CAstOperand {$/;"	c
CAstType	src/ast.cpp	/^	CAstType::CAstType(CToken t, const CType *type)$/;"	f	class:CAstType
CAstType	src/ast.h	/^class CAstType : public CAstNode {$/;"	c
CAstUnaryOp	src/ast.cpp	/^	CAstUnaryOp::CAstUnaryOp(CToken t, EOperation oper, CAstExpression *e)$/;"	f	class:CAstUnaryOp
CAstUnaryOp	src/ast.h	/^class CAstUnaryOp : public CAstOperation {$/;"	c
CBackend	src/backend.cpp	/^CBackend::CBackend(ostream &out)$/;"	f	class:CBackend
CBackend	src/backend.h	/^class CBackend {$/;"	c
CBackendx86	src/backend.cpp	/^CBackendx86::CBackendx86(ostream &out)$/;"	f	class:CBackendx86
CBackendx86	src/backend.h	/^class CBackendx86 : public CBackend {$/;"	c
CBoolType	src/type.cpp	/^CBoolType::CBoolType(void)$/;"	f	class:CBoolType
CBoolType	src/type.h	/^class CBoolType : public CScalarType {$/;"	c
CC	Makefile	/^CC=g++$/;"	m
CCFLAGS	Makefile	/^CCFLAGS=-std=c++0x -g -O0$/;"	m
CCharType	src/type.cpp	/^CCharType::CCharType(void)$/;"	f	class:CCharType
CCharType	src/type.h	/^class CCharType : public CScalarType {$/;"	c
CCodeBlock	src/ir.cpp	/^CCodeBlock::CCodeBlock(CScope *owner)$/;"	f	class:CCodeBlock
CCodeBlock	src/ir.h	/^class CCodeBlock {$/;"	c
CDataInitString	src/data.cpp	/^CDataInitString::CDataInitString(const string data)$/;"	f	class:CDataInitString
CDataInitString	src/data.h	/^class CDataInitString : public CDataInitializer {$/;"	c
CDataInitializer	src/data.cpp	/^CDataInitializer::CDataInitializer(void)$/;"	f	class:CDataInitializer
CDataInitializer	src/data.h	/^class CDataInitializer {$/;"	c
CIntType	src/type.cpp	/^CIntType::CIntType(void)$/;"	f	class:CIntType
CIntType	src/type.h	/^class CIntType : public CScalarType {$/;"	c
CModule	src/ir.cpp	/^CModule::CModule(CAstNode *ast)$/;"	f	class:CModule
CModule	src/ir.h	/^class CModule : public CScope {$/;"	c
CNullType	src/type.cpp	/^CNullType::CNullType(void)$/;"	f	class:CNullType
CNullType	src/type.h	/^class CNullType : public CScalarType {$/;"	c
CParser	src/parser.cpp	/^CParser::CParser(CScanner *scanner)$/;"	f	class:CParser
CParser	src/parser.h	/^class CParser {$/;"	c
CPointerType	src/type.cpp	/^CPointerType::CPointerType(const CType *basetype)$/;"	f	class:CPointerType
CPointerType	src/type.h	/^class CPointerType : public CScalarType {$/;"	c
CProcedure	src/ir.cpp	/^CProcedure::CProcedure(CAstNode *ast, CScope *parent)$/;"	f	class:CProcedure
CProcedure	src/ir.h	/^class CProcedure : public CScope {$/;"	c
CScalarType	src/type.h	/^class CScalarType : public CType {$/;"	c
CScanner	src/scanner.cpp	/^CScanner::CScanner(istream *in)$/;"	f	class:CScanner
CScanner	src/scanner.cpp	/^CScanner::CScanner(string in)$/;"	f	class:CScanner
CScanner	src/scanner.h	/^class CScanner {$/;"	c
CScope	src/ir.cpp	/^CScope::CScope(CAstNode *ast, CScope *parent)$/;"	f	class:CScope
CScope	src/ir.h	/^class CScope {$/;"	c
CSymGlobal	src/symtab.cpp	/^CSymGlobal::CSymGlobal(const string name, const CType *type)$/;"	f	class:CSymGlobal
CSymGlobal	src/symtab.h	/^class CSymGlobal : public CSymbol {$/;"	c
CSymLocal	src/symtab.cpp	/^CSymLocal::CSymLocal(const string name, ESymbolType stype, const CType *type)$/;"	f	class:CSymLocal
CSymLocal	src/symtab.cpp	/^CSymLocal::CSymLocal(const string name, const CType *type)$/;"	f	class:CSymLocal
CSymLocal	src/symtab.h	/^class CSymLocal : public CSymbol {$/;"	c
CSymParam	src/symtab.cpp	/^CSymParam::CSymParam(int index, const string name, const CType *type)$/;"	f	class:CSymParam
CSymParam	src/symtab.h	/^class CSymParam : public CSymLocal {$/;"	c
CSymProc	src/symtab.cpp	/^CSymProc::CSymProc(const string name, const CType *return_type)$/;"	f	class:CSymProc
CSymProc	src/symtab.h	/^class CSymProc : public CSymbol {$/;"	c
CSymbol	src/symtab.cpp	/^CSymbol::CSymbol(const string name, ESymbolType stype, const CType *dtype)$/;"	f	class:CSymbol
CSymbol	src/symtab.h	/^class CSymbol {$/;"	c
CSymtab	src/symtab.cpp	/^CSymtab::CSymtab(CSymtab *parent)$/;"	f	class:CSymtab
CSymtab	src/symtab.cpp	/^CSymtab::CSymtab(void)$/;"	f	class:CSymtab
CSymtab	src/symtab.h	/^class CSymtab {$/;"	c
CTac	src/ir.cpp	/^CTac::CTac(void)$/;"	f	class:CTac
CTac	src/ir.h	/^class CTac {$/;"	c
CTacAddr	src/ir.cpp	/^CTacAddr::CTacAddr(void)$/;"	f	class:CTacAddr
CTacAddr	src/ir.h	/^class CTacAddr : public CTac {$/;"	c
CTacConst	src/ir.cpp	/^CTacConst::CTacConst(int value)$/;"	f	class:CTacConst
CTacConst	src/ir.h	/^class CTacConst : public CTacAddr {$/;"	c
CTacInstr	src/ir.cpp	/^CTacInstr::CTacInstr(EOperation op, CTac *dst, CTacAddr *src1, CTacAddr *src2)$/;"	f	class:CTacInstr
CTacInstr	src/ir.cpp	/^CTacInstr::CTacInstr(string name)$/;"	f	class:CTacInstr
CTacInstr	src/ir.h	/^class CTacInstr : public CTac {$/;"	c
CTacLabel	src/ir.cpp	/^CTacLabel::CTacLabel(const string label)$/;"	f	class:CTacLabel
CTacLabel	src/ir.h	/^class CTacLabel : public CTacInstr {$/;"	c
CTacName	src/ir.cpp	/^CTacName::CTacName(const CSymbol *symbol)$/;"	f	class:CTacName
CTacName	src/ir.h	/^class CTacName : public CTacAddr {$/;"	c
CTacReference	src/ir.cpp	/^CTacReference::CTacReference(const CSymbol *symbol)$/;"	f	class:CTacReference
CTacReference	src/ir.h	/^class CTacReference: public CTacName {$/;"	c
CTacTemp	src/ir.cpp	/^CTacTemp::CTacTemp(const CSymbol *symbol)$/;"	f	class:CTacTemp
CTacTemp	src/ir.h	/^class CTacTemp: public CTacName {$/;"	c
CToken	src/scanner.cpp	/^CToken::CToken()$/;"	f	class:CToken
CToken	src/scanner.cpp	/^CToken::CToken(const CToken &token)$/;"	f	class:CToken
CToken	src/scanner.cpp	/^CToken::CToken(const CToken *token)$/;"	f	class:CToken
CToken	src/scanner.cpp	/^CToken::CToken(int line, int charpos, EToken type, const string value)$/;"	f	class:CToken
CToken	src/scanner.h	/^class CToken {$/;"	c
CType	src/type.cpp	/^CType::CType(void)$/;"	f	class:CType
CType	src/type.h	/^class CType {$/;"	c
CTypeManager	src/type.cpp	/^CTypeManager::CTypeManager(void)$/;"	f	class:CTypeManager
CTypeManager	src/type.h	/^class CTypeManager {$/;"	c
CleanupControlFlow	src/ir.cpp	/^void CCodeBlock::CleanupControlFlow(void)$/;"	f	class:CCodeBlock
Compare	src/type.cpp	/^bool CArrayType::Compare(const CType *t) const$/;"	f	class:CArrayType
Compare	src/type.cpp	/^bool CPointerType::Compare(const CType *t) const$/;"	f	class:CPointerType
Compare	src/type.cpp	/^bool CType::Compare(const CType *t) const$/;"	f	class:CType
ComputeStackOffsets	src/backend.cpp	/^size_t CBackendx86::ComputeStackOffsets(CSymtab *symtab,$/;"	f	class:CBackendx86
Condition	src/backend.cpp	/^string CBackendx86::Condition(EOperation cond) const$/;"	f	class:CBackendx86
Consume	src/parser.cpp	/^bool CParser::Consume(EToken type, CToken *token)$/;"	f	class:CParser
CreateLabel	src/ir.cpp	/^CTacLabel* CCodeBlock::CreateLabel(const char *hint)$/;"	f	class:CCodeBlock
CreateLabel	src/ir.cpp	/^CTacLabel* CScope::CreateLabel(const char *hint)$/;"	f	class:CScope
CreateTemp	src/ir.cpp	/^CTacTemp* CCodeBlock::CreateTemp(const CType *type)$/;"	f	class:CCodeBlock
CreateTemp	src/ir.cpp	/^CTacTemp* CScope::CreateTemp(const CType *type)$/;"	f	class:CScope
CreateVar	src/ast.cpp	/^CSymbol* CAstModule::CreateVar(const string ident, const CType *type)$/;"	f	class:CAstModule
CreateVar	src/ast.cpp	/^CSymbol* CAstProcedure::CreateVar(const string ident, const CType *type)$/;"	f	class:CAstProcedure
DEPS	Makefile	/^DEPS=scanner.h \\$/;"	m
DEPS_	Makefile	/^DEPS_=$(patsubst %,$(SRC_DIR)\/%,$(DEPS))$/;"	m
Dprintf	src/ast.cpp	48;"	d	file:
DumpAST	src/snuplc.cpp	/^void DumpAST(string file, CAstModule *ast)$/;"	f
DumpTAC	src/snuplc.cpp	/^void DumpTAC(string file, CModule *m)$/;"	f
EOperation	src/ir.h	/^enum EOperation {$/;"	g
EOperationName	src/ir.cpp	/^char EOperationName[][OPERATION_STRLEN] = {$/;"	v
EScope	src/symtab.h	/^enum EScope {$/;"	g
ESymbolType	src/symtab.h	/^enum ESymbolType {$/;"	g
EToken	src/scanner.h	/^enum EToken {$/;"	g
ETokenName	src/scanner.cpp	/^char ETokenName[][TOKEN_STRLEN] = {$/;"	v
ETokenStr	src/scanner.cpp	/^char ETokenStr[][TOKEN_STRLEN] = {$/;"	v
Emit	src/backend.cpp	/^bool CBackend::Emit(CModule *m)$/;"	f	class:CBackend
EmitCode	src/backend.cpp	/^void CBackend::EmitCode(void)$/;"	f	class:CBackend
EmitCode	src/backend.cpp	/^void CBackendx86::EmitCode(void)$/;"	f	class:CBackendx86
EmitCodeBlock	src/backend.cpp	/^void CBackendx86::EmitCodeBlock(CCodeBlock *cb)$/;"	f	class:CBackendx86
EmitData	src/backend.cpp	/^void CBackend::EmitData(void)$/;"	f	class:CBackend
EmitData	src/backend.cpp	/^void CBackendx86::EmitData(void)$/;"	f	class:CBackendx86
EmitFooter	src/backend.cpp	/^void CBackend::EmitFooter(void)$/;"	f	class:CBackend
EmitFooter	src/backend.cpp	/^void CBackendx86::EmitFooter(void)$/;"	f	class:CBackendx86
EmitGlobalData	src/backend.cpp	/^void CBackendx86::EmitGlobalData(CScope *scope)$/;"	f	class:CBackendx86
EmitHeader	src/backend.cpp	/^void CBackend::EmitHeader(void)$/;"	f	class:CBackend
EmitHeader	src/backend.cpp	/^void CBackendx86::EmitHeader(void)$/;"	f	class:CBackendx86
EmitInstruction	src/backend.cpp	/^void CBackendx86::EmitInstruction(CTacInstr *i)$/;"	f	class:CBackendx86
EmitInstruction	src/backend.cpp	/^void CBackendx86::EmitInstruction(string mnemonic, string args, string comment)$/;"	f	class:CBackendx86
EmitLocalData	src/backend.cpp	/^void CBackendx86::EmitLocalData(CScope *scope)$/;"	f	class:CBackendx86
EmitScope	src/backend.cpp	/^void CBackendx86::EmitScope(CScope *scope)$/;"	f	class:CBackendx86
FindSymbol	src/symtab.cpp	/^const CSymbol* CSymtab::FindSymbol(const string name, EScope scope) const$/;"	f	class:CSymtab
Get	src/scanner.cpp	/^CToken CScanner::Get()$/;"	f	class:CScanner
Get	src/type.cpp	/^CTypeManager* CTypeManager::Get(void)$/;"	f	class:CTypeManager
GetAlign	src/type.cpp	/^int CArrayType::GetAlign(void) const$/;"	f	class:CArrayType
GetAlign	src/type.h	/^    virtual int GetAlign(void) const { return 0; };$/;"	f	class:CNullType
GetAlign	src/type.h	/^    virtual int GetAlign(void) const { return 1; };$/;"	f	class:CBoolType
GetAlign	src/type.h	/^    virtual int GetAlign(void) const { return 1; };$/;"	f	class:CCharType
GetAlign	src/type.h	/^    virtual int GetAlign(void) const { return 4; };$/;"	f	class:CIntType
GetAlign	src/type.h	/^    virtual int GetAlign(void) const { return 4; };$/;"	f	class:CPointerType
GetArg	src/ast.cpp	/^CAstExpression* CAstFunctionCall::GetArg(int index) const$/;"	f	class:CAstFunctionCall
GetArray	src/type.cpp	/^const CArrayType* CTypeManager::GetArray(int nelem, const CType *innertype)$/;"	f	class:CTypeManager
GetBaseRegister	src/symtab.cpp	/^string CSymbol::GetBaseRegister(void) const$/;"	f	class:CSymbol
GetBaseType	src/type.cpp	/^const CType* CArrayType::GetBaseType(void) const$/;"	f	class:CArrayType
GetBaseType	src/type.h	/^    const CType* GetBaseType(void) const { return _basetype; };$/;"	f	class:CPointerType
GetBody	src/ast.cpp	/^CAstStatement* CAstStatWhile::GetBody(void) const$/;"	f	class:CAstStatWhile
GetBool	src/type.cpp	/^const CBoolType* CTypeManager::GetBool(void) const$/;"	f	class:CTypeManager
GetCall	src/ast.cpp	/^CAstFunctionCall* CAstStatCall::GetCall(void) const$/;"	f	class:CAstStatCall
GetChar	src/scanner.cpp	/^char CScanner::GetChar()$/;"	f	class:CScanner
GetChar	src/scanner.cpp	/^string CScanner::GetChar(int n)$/;"	f	class:CScanner
GetChar	src/type.cpp	/^const CCharType* CTypeManager::GetChar(void) const$/;"	f	class:CTypeManager
GetCharPosition	src/scanner.h	/^    int GetCharPosition() const { return _char; };$/;"	f	class:CScanner
GetCharPosition	src/scanner.h	/^  int GetCharPosition(void) const { return _char; };$/;"	f	class:CToken
GetChild	src/ast.cpp	/^CAstScope* CAstScope::GetChild(size_t i) const$/;"	f	class:CAstScope
GetCodeBlock	src/ast.cpp	/^CCodeBlock* CAstScope::GetCodeBlock(void) const$/;"	f	class:CAstScope
GetCodeBlock	src/ir.cpp	/^CCodeBlock* CScope::GetCodeBlock(void) const$/;"	f	class:CScope
GetCondition	src/ast.cpp	/^CAstExpression* CAstStatIf::GetCondition(void) const$/;"	f	class:CAstStatIf
GetCondition	src/ast.cpp	/^CAstExpression* CAstStatWhile::GetCondition(void) const$/;"	f	class:CAstStatWhile
GetData	src/data.cpp	/^string CDataInitString::GetData(void) const$/;"	f	class:CDataInitString
GetData	src/symtab.cpp	/^const CDataInitializer* CSymbol::GetData(void) const$/;"	f	class:CSymbol
GetDataSize	src/type.cpp	/^int CArrayType::GetDataSize(void) const$/;"	f	class:CArrayType
GetDataSize	src/type.cpp	/^int CType::GetDataSize(void) const$/;"	f	class:CType
GetDataType	src/symtab.cpp	/^const CType* CSymbol::GetDataType(void) const$/;"	f	class:CSymbol
GetDeclaration	src/ir.cpp	/^CSymbol* CModule::GetDeclaration(void) const$/;"	f	class:CModule
GetDeclaration	src/ir.cpp	/^CSymbol* CProcedure::GetDeclaration(void) const$/;"	f	class:CProcedure
GetDest	src/ir.cpp	/^CTac* CTacInstr::GetDest(void) const$/;"	f	class:CTacInstr
GetElseBody	src/ast.cpp	/^CAstStatement* CAstStatIf::GetElseBody(void) const$/;"	f	class:CAstStatIf
GetErrorMessage	src/parser.cpp	/^string CParser::GetErrorMessage(void) const$/;"	f	class:CParser
GetErrorToken	src/parser.cpp	/^const CToken* CParser::GetErrorToken(void) const$/;"	f	class:CParser
GetExpression	src/ast.cpp	/^CAstExpression* CAstStatReturn::GetExpression(void) const$/;"	f	class:CAstStatReturn
GetID	src/ast.cpp	/^int CAstNode::GetID(void) const$/;"	f	class:CAstNode
GetId	src/ir.cpp	/^unsigned int CTacInstr::GetId(void) const$/;"	f	class:CTacInstr
GetIfBody	src/ast.cpp	/^CAstStatement* CAstStatIf::GetIfBody(void) const$/;"	f	class:CAstStatIf
GetIndex	src/ast.cpp	/^CAstExpression* CAstArrayDesignator::GetIndex(int index) const$/;"	f	class:CAstArrayDesignator
GetIndex	src/symtab.cpp	/^int CSymParam::GetIndex(void) const$/;"	f	class:CSymParam
GetInnerType	src/type.h	/^    const CType* GetInnerType(void) const { return _innertype; };$/;"	f	class:CArrayType
GetInstr	src/ir.cpp	/^const list<CTacInstr*>& CCodeBlock::GetInstr(void) const$/;"	f	class:CCodeBlock
GetInt	src/type.cpp	/^const CIntType* CTypeManager::GetInt(void) const$/;"	f	class:CTypeManager
GetLHS	src/ast.cpp	/^CAstDesignator* CAstStatAssign::GetLHS(void) const$/;"	f	class:CAstStatAssign
GetLabel	src/ir.cpp	/^const string CTacLabel::GetLabel(void) const$/;"	f	class:CTacLabel
GetLeft	src/ast.cpp	/^CAstExpression* CAstBinaryOp::GetLeft(void) const$/;"	f	class:CAstBinaryOp
GetLineNumber	src/scanner.h	/^    int GetLineNumber(void) const { return _line; };$/;"	f	class:CScanner
GetLineNumber	src/scanner.h	/^  int GetLineNumber(void) const { return _line; };$/;"	f	class:CToken
GetNArgs	src/ast.cpp	/^int CAstFunctionCall::GetNArgs(void) const$/;"	f	class:CAstFunctionCall
GetNDim	src/type.cpp	/^int CArrayType::GetNDim(void) const$/;"	f	class:CArrayType
GetNElem	src/type.h	/^    int GetNElem(void) const { return _nelem; };$/;"	f	class:CArrayType
GetNIndices	src/ast.cpp	/^int CAstArrayDesignator::GetNIndices(void) const$/;"	f	class:CAstArrayDesignator
GetNParams	src/symtab.cpp	/^int CSymProc::GetNParams(void) const$/;"	f	class:CSymProc
GetName	src/ast.cpp	/^const string CAstScope::GetName(void) const$/;"	f	class:CAstScope
GetName	src/ir.cpp	/^string CCodeBlock::GetName(void) const$/;"	f	class:CCodeBlock
GetName	src/ir.cpp	/^string CScope::GetName(void) const$/;"	f	class:CScope
GetName	src/scanner.cpp	/^const string CToken::GetName(void) const$/;"	f	class:CToken
GetName	src/symtab.cpp	/^string CSymbol::GetName(void) const$/;"	f	class:CSymbol
GetNext	src/ast.cpp	/^CAstStatement* CAstStatement::GetNext(void) const$/;"	f	class:CAstStatement
GetNull	src/type.cpp	/^const CNullType* CTypeManager::GetNull(void) const$/;"	f	class:CTypeManager
GetNumChildren	src/ast.cpp	/^size_t CAstScope::GetNumChildren(void) const$/;"	f	class:CAstScope
GetNumSrc	src/ir.cpp	/^unsigned int CTacInstr::GetNumSrc(void) const$/;"	f	class:CTacInstr
GetOffset	src/symtab.cpp	/^int CSymbol::GetOffset(void) const$/;"	f	class:CSymbol
GetOperand	src/ast.cpp	/^CAstExpression* CAstSpecialOp::GetOperand(void) const$/;"	f	class:CAstSpecialOp
GetOperand	src/ast.cpp	/^CAstExpression* CAstUnaryOp::GetOperand(void) const$/;"	f	class:CAstUnaryOp
GetOperation	src/ast.cpp	/^EOperation CAstOperation::GetOperation(void) const$/;"	f	class:CAstOperation
GetOperation	src/ir.cpp	/^EOperation CTacInstr::GetOperation(void) const$/;"	f	class:CTacInstr
GetOwner	src/ir.cpp	/^CScope* CCodeBlock::GetOwner(void) const$/;"	f	class:CCodeBlock
GetParam	src/symtab.cpp	/^const CSymParam* CSymProc::GetParam(int index) const$/;"	f	class:CSymProc
GetParent	src/ast.cpp	/^CAstScope* CAstScope::GetParent(void) const$/;"	f	class:CAstScope
GetParent	src/ir.cpp	/^CScope* CScope::GetParent(void) const$/;"	f	class:CScope
GetPointer	src/type.cpp	/^const CPointerType* CTypeManager::GetPointer(const CType *basetype)$/;"	f	class:CTypeManager
GetRHS	src/ast.cpp	/^CAstExpression* CAstStatAssign::GetRHS(void) const$/;"	f	class:CAstStatAssign
GetRecordedStreamPosition	src/scanner.cpp	/^void CScanner::GetRecordedStreamPosition(int *lineno, int *charpos)$/;"	f	class:CScanner
GetRefCnt	src/ir.cpp	/^int CTacLabel::GetRefCnt(void) const$/;"	f	class:CTacLabel
GetRight	src/ast.cpp	/^CAstExpression* CAstBinaryOp::GetRight(void) const$/;"	f	class:CAstBinaryOp
GetScope	src/ast.cpp	/^CAstScope* CAstStatReturn::GetScope(void) const$/;"	f	class:CAstStatReturn
GetScope	src/backend.cpp	/^CScope* CBackendx86::GetScope(void) const$/;"	f	class:CBackendx86
GetSize	src/type.cpp	/^int CArrayType::GetSize(void) const$/;"	f	class:CArrayType
GetSize	src/type.h	/^    virtual int GetSize(void) const { return 0; };$/;"	f	class:CNullType
GetSize	src/type.h	/^    virtual int GetSize(void) const { return 1; };$/;"	f	class:CBoolType
GetSize	src/type.h	/^    virtual int GetSize(void) const { return 1; };$/;"	f	class:CCharType
GetSize	src/type.h	/^    virtual int GetSize(void) const { return 4; };$/;"	f	class:CIntType
GetSize	src/type.h	/^    virtual int GetSize(void) const { return 4; };$/;"	f	class:CPointerType
GetSrc	src/ir.cpp	/^CTacAddr* CTacInstr::GetSrc(int index) const$/;"	f	class:CTacInstr
GetStatementSequence	src/ast.cpp	/^CAstStatement* CAstScope::GetStatementSequence(void) const$/;"	f	class:CAstScope
GetSubscopes	src/ir.cpp	/^const vector<CScope*>& CScope::GetSubscopes(void) const$/;"	f	class:CScope
GetSymbol	src/ast.cpp	/^CSymGlobal* CAstStringConstant::GetSymbol(void) const {$/;"	f	class:CAstStringConstant
GetSymbol	src/ast.cpp	/^CSymProc* CAstProcedure::GetSymbol(void) const$/;"	f	class:CAstProcedure
GetSymbol	src/ast.cpp	/^const CSymProc* CAstFunctionCall::GetSymbol(void) const$/;"	f	class:CAstFunctionCall
GetSymbol	src/ast.cpp	/^const CSymbol* CAstDesignator::GetSymbol(void) const$/;"	f	class:CAstDesignator
GetSymbol	src/ir.cpp	/^const CSymbol* CTacName::GetSymbol(void) const$/;"	f	class:CTacName
GetSymbolTable	src/ast.cpp	/^CSymtab* CAstScope::GetSymbolTable(void) const$/;"	f	class:CAstScope
GetSymbolTable	src/ir.cpp	/^CSymtab* CScope::GetSymbolTable(void) const$/;"	f	class:CScope
GetSymbolTable	src/symtab.cpp	/^CSymtab* CSymbol::GetSymbolTable(void) const$/;"	f	class:CSymbol
GetSymbolType	src/symtab.cpp	/^ESymbolType CSymbol::GetSymbolType(void) const$/;"	f	class:CSymbol
GetSymbols	src/symtab.cpp	/^vector<CSymbol*> CSymtab::GetSymbols(void) const$/;"	f	class:CSymtab
GetTacAddr	src/ast.cpp	/^CTacAddr* CAstNode::GetTacAddr(void) const$/;"	f	class:CAstNode
GetToken	src/ast.cpp	/^CToken CAstNode::GetToken(void) const$/;"	f	class:CAstNode
GetType	src/ast.cpp	/^const CType* CAstArrayDesignator::GetType(void) const$/;"	f	class:CAstArrayDesignator
GetType	src/ast.cpp	/^const CType* CAstBinaryOp::GetType(void) const$/;"	f	class:CAstBinaryOp
GetType	src/ast.cpp	/^const CType* CAstConstant::GetType(void) const$/;"	f	class:CAstConstant
GetType	src/ast.cpp	/^const CType* CAstDesignator::GetType(void) const$/;"	f	class:CAstDesignator
GetType	src/ast.cpp	/^const CType* CAstFunctionCall::GetType(void) const$/;"	f	class:CAstFunctionCall
GetType	src/ast.cpp	/^const CType* CAstNode::GetType(void) const$/;"	f	class:CAstNode
GetType	src/ast.cpp	/^const CType* CAstProcedure::GetType(void) const$/;"	f	class:CAstProcedure
GetType	src/ast.cpp	/^const CType* CAstSpecialOp::GetType(void) const$/;"	f	class:CAstSpecialOp
GetType	src/ast.cpp	/^const CType* CAstStatAssign::GetType(void) const$/;"	f	class:CAstStatAssign
GetType	src/ast.cpp	/^const CType* CAstStatReturn::GetType(void) const$/;"	f	class:CAstStatReturn
GetType	src/ast.cpp	/^const CType* CAstStringConstant::GetType(void) const$/;"	f	class:CAstStringConstant
GetType	src/ast.cpp	/^const CType* CAstType::GetType(void) const$/;"	f	class:CAstType
GetType	src/ast.cpp	/^const CType* CAstUnaryOp::GetType(void) const$/;"	f	class:CAstUnaryOp
GetType	src/scanner.h	/^  EToken GetType(void) const { return _type; };$/;"	f	class:CToken
GetValue	src/ast.cpp	/^const string CAstStringConstant::GetValue(void) const$/;"	f	class:CAstStringConstant
GetValue	src/ast.cpp	/^long long CAstConstant::GetValue(void) const$/;"	f	class:CAstConstant
GetValue	src/ir.cpp	/^int CTacConst::GetValue(void) const$/;"	f	class:CTacConst
GetValue	src/scanner.h	/^  string GetValue(void) const { return _value; };$/;"	f	class:CToken
GetValueStr	src/ast.cpp	/^const string CAstStringConstant::GetValueStr(void) const$/;"	f	class:CAstStringConstant
GetValueStr	src/ast.cpp	/^string CAstConstant::GetValueStr(void) const$/;"	f	class:CAstConstant
GetVoidPtr	src/type.cpp	/^const CPointerType* CTypeManager::GetVoidPtr(void) const$/;"	f	class:CTypeManager
Good	src/scanner.h	/^    bool Good(void) const { return _good; };$/;"	f	class:CScanner
HasError	src/parser.h	/^		bool HasError(void) const { return _abort; };$/;"	f	class:CParser
IR	Makefile	/^IR=$/;"	m
Imm	src/backend.cpp	/^string CBackendx86::Imm(int value) const$/;"	f	class:CBackendx86
IndicesComplete	src/ast.cpp	/^void CAstArrayDesignator::IndicesComplete(void)$/;"	f	class:CAstArrayDesignator
InitKeywords	src/scanner.cpp	/^void CScanner::InitKeywords(void)$/;"	f	class:CScanner
InitSymbolTable	src/parser.cpp	/^void CParser::InitSymbolTable(CSymtab *s)$/;"	f	class:CParser
IsASCII	src/scanner.cpp	/^bool CScanner::IsASCII(char c) const$/;"	f	class:CScanner
IsArith	src/ast.cpp	/^bool IsArith(EOperation t) {$/;"	f
IsArray	src/type.h	/^    virtual bool IsArray(void) const { return false; };$/;"	f	class:CType
IsArray	src/type.h	/^    virtual bool IsArray(void) const { return true; };$/;"	f	class:CArrayType
IsBoolean	src/type.h	/^    virtual bool IsBoolean(void) const { return false; };$/;"	f	class:CType
IsBoolean	src/type.h	/^    virtual bool IsBoolean(void) const { return true; };$/;"	f	class:CBoolType
IsBranch	src/ir.cpp	/^bool CTacInstr::IsBranch(void) const$/;"	f	class:CTacInstr
IsChar	src/type.h	/^    virtual bool IsChar(void) const { return false; };$/;"	f	class:CType
IsChar	src/type.h	/^    virtual bool IsChar(void) const { return true; };$/;"	f	class:CCharType
IsDigit	src/scanner.cpp	/^bool CScanner::IsDigit(char c) const$/;"	f	class:CScanner
IsInt	src/type.h	/^    virtual bool IsInt(void) const { return false; };$/;"	f	class:CType
IsInt	src/type.h	/^    virtual bool IsInt(void) const { return true; };$/;"	f	class:CIntType
IsLetter	src/scanner.cpp	/^bool CScanner::IsLetter(char c) const$/;"	f	class:CScanner
IsLogic	src/ast.cpp	/^bool IsLogic(EOperation t) {	$/;"	f
IsNull	src/type.h	/^    virtual bool IsNull(void) const { return false; };$/;"	f	class:CType
IsNull	src/type.h	/^    virtual bool IsNull(void) const { return true; };$/;"	f	class:CNullType
IsPointer	src/type.h	/^    virtual bool IsPointer(void) const { return false; };$/;"	f	class:CType
IsPointer	src/type.h	/^    virtual bool IsPointer(void) const { return true; };$/;"	f	class:CPointerType
IsRelOp	src/ast.cpp	/^bool IsRelOp(EOperation t) {	$/;"	f
IsScalar	src/type.h	/^    virtual bool IsScalar(void) const { return false; };$/;"	f	class:CType
IsScalar	src/type.h	/^    virtual bool IsScalar(void) const { return true; };$/;"	f	class:CBoolType
IsScalar	src/type.h	/^    virtual bool IsScalar(void) const { return true; };$/;"	f	class:CCharType
IsScalar	src/type.h	/^    virtual bool IsScalar(void) const { return true; };$/;"	f	class:CIntType
IsScalar	src/type.h	/^    virtual bool IsScalar(void) const { return true; };$/;"	f	class:CPointerType
IsWhite	src/scanner.cpp	/^bool CScanner::IsWhite(char c) const$/;"	f	class:CScanner
Keywords	src/scanner.cpp	/^pair<const char*, EToken> Keywords[] =$/;"	v
Label	src/backend.cpp	/^string CBackendx86::Label(const CTacLabel* label) const$/;"	f	class:CBackendx86
Label	src/backend.cpp	/^string CBackendx86::Label(string label) const$/;"	f	class:CBackendx86
Load	src/backend.cpp	/^void CBackendx86::Load(CTacAddr *src, string dst, string comment)$/;"	f	class:CBackendx86
Match	src/type.cpp	/^bool CArrayType::Match(const CType *t) const$/;"	f	class:CArrayType
Match	src/type.cpp	/^bool CPointerType::Match(const CType *t) const$/;"	f	class:CPointerType
Match	src/type.cpp	/^bool CScalarType::Match(const CType *t) const$/;"	f	class:CScalarType
Name	src/scanner.cpp	/^const string CToken::Name(EToken type)$/;"	f	class:CToken
NewToken	src/scanner.cpp	/^CToken* CScanner::NewToken(EToken type, const string token)$/;"	f	class:CScanner
NextToken	src/scanner.cpp	/^void CScanner::NextToken()$/;"	f	class:CScanner
OBJ_DIR	Makefile	/^OBJ_DIR=obj$/;"	m
OBJ_IR	Makefile	/^OBJ_IR=$(patsubst %.cpp,$(OBJ_DIR)\/%.o,$(IR) $(PARSER) $(SCANNER))$/;"	m
OBJ_PARSER	Makefile	/^OBJ_PARSER=$(patsubst %.cpp,$(OBJ_DIR)\/%.o,$(PARSER) $(SCANNER))$/;"	m
OBJ_SCANNER	Makefile	/^OBJ_SCANNER=$(patsubst %.cpp,$(OBJ_DIR)\/%.o,$(SCANNER))$/;"	m
OBJ_SNUPLC	Makefile	/^OBJ_SNUPLC=$(patsubst %.cpp,$(OBJ_DIR)\/%.o, \\$/;"	m
OPEN	src/type.h	/^    const static int OPEN = -1;   \/\/\/< open array (dimensions unspecified)$/;"	m	class:CArrayType
OPERATION_STRLEN	src/ir.cpp	48;"	d	file:
Operand	src/backend.cpp	/^string CBackendx86::Operand(const CTac *op)$/;"	f	class:CBackendx86
OperandSize	src/backend.cpp	/^int CBackendx86::OperandSize(CTac *t) const$/;"	f	class:CBackendx86
PARSER	Makefile	/^PARSER=parser.cpp \\$/;"	m
Parse	src/parser.cpp	/^CAstNode* CParser::Parse(void)$/;"	f	class:CParser
ParseArgs	src/snuplc.cpp	/^void ParseArgs(int argc, char *argv[])$/;"	f
Peek	src/scanner.cpp	/^CToken CScanner::Peek() const$/;"	f	class:CScanner
RecordStreamPosition	src/scanner.cpp	/^void CScanner::RecordStreamPosition()$/;"	f	class:CScanner
RunCompile	src/snuplc.cpp	/^void RunCompile(string file)$/;"	f
RunDOT	src/snuplc.cpp	/^void RunDOT(string file)$/;"	f
SCANNER	Makefile	/^SCANNER=scanner.cpp$/;"	m
SRC_DIR	Makefile	/^SRC_DIR=src$/;"	m
Scan	src/scanner.cpp	/^CToken* CScanner::Scan()$/;"	f	class:CScanner
SetBaseRegister	src/symtab.cpp	/^void CSymbol::SetBaseRegister(string rbase)$/;"	f	class:CSymbol
SetData	src/symtab.cpp	/^void CSymbol::SetData(const CDataInitializer *data)$/;"	f	class:CSymbol
SetDataType	src/symtab.cpp	/^void CSymbol::SetDataType(const CType *datatype)$/;"	f	class:CSymbol
SetDest	src/ir.cpp	/^void CTacInstr::SetDest(CTac* dst)$/;"	f	class:CTacInstr
SetError	src/parser.cpp	/^void CParser::SetError(CToken t, const string message)$/;"	f	class:CParser
SetId	src/ir.cpp	/^void CTacInstr::SetId(unsigned int id)$/;"	f	class:CTacInstr
SetNext	src/ast.cpp	/^void CAstStatement::SetNext(CAstStatement *next)$/;"	f	class:CAstStatement
SetOffset	src/symtab.cpp	/^void CSymbol::SetOffset(int offset)$/;"	f	class:CSymbol
SetScope	src/backend.cpp	/^void CBackendx86::SetScope(CScope *scope)$/;"	f	class:CBackendx86
SetStatementSequence	src/ast.cpp	/^void CAstScope::SetStatementSequence(CAstStatement *statseq)$/;"	f	class:CAstScope
SetSymbolTable	src/ast.cpp	/^void CAstScope::SetSymbolTable(CSymtab *st)$/;"	f	class:CAstScope
SetSymbolTable	src/symtab.cpp	/^void CSymbol::SetSymbolTable(CSymtab *symtab)$/;"	f	class:CSymbol
SetValue	src/ast.cpp	/^void CAstConstant::SetValue(long long value)$/;"	f	class:CAstConstant
Store	src/backend.cpp	/^void CBackendx86::Store(CTac *dst, char src_base, string comment)$/;"	f	class:CBackendx86
Syntax	src/snuplc.cpp	/^void Syntax(string msg)$/;"	f
TOKEN_STRLEN	src/scanner.cpp	50;"	d	file:
ToTac	src/ast.cpp	/^CTacAddr* CAstArrayDesignator::ToTac(CCodeBlock *cb)$/;"	f	class:CAstArrayDesignator
ToTac	src/ast.cpp	/^CTacAddr* CAstArrayDesignator::ToTac(CCodeBlock *cb, CTacLabel *ltrue, CTacLabel *lfalse)$/;"	f	class:CAstArrayDesignator
ToTac	src/ast.cpp	/^CTacAddr* CAstBinaryOp::ToTac(CCodeBlock *cb)$/;"	f	class:CAstBinaryOp
ToTac	src/ast.cpp	/^CTacAddr* CAstBinaryOp::ToTac(CCodeBlock *cb, CTacLabel *ltrue, CTacLabel *lfalse)$/;"	f	class:CAstBinaryOp
ToTac	src/ast.cpp	/^CTacAddr* CAstConstant::ToTac(CCodeBlock *cb)$/;"	f	class:CAstConstant
ToTac	src/ast.cpp	/^CTacAddr* CAstConstant::ToTac(CCodeBlock *cb, CTacLabel *ltrue, CTacLabel *lfalse)$/;"	f	class:CAstConstant
ToTac	src/ast.cpp	/^CTacAddr* CAstDesignator::ToTac(CCodeBlock *cb)$/;"	f	class:CAstDesignator
ToTac	src/ast.cpp	/^CTacAddr* CAstDesignator::ToTac(CCodeBlock *cb,$/;"	f	class:CAstDesignator
ToTac	src/ast.cpp	/^CTacAddr* CAstExpression::ToTac(CCodeBlock *cb)$/;"	f	class:CAstExpression
ToTac	src/ast.cpp	/^CTacAddr* CAstExpression::ToTac(CCodeBlock *cb,$/;"	f	class:CAstExpression
ToTac	src/ast.cpp	/^CTacAddr* CAstFunctionCall::ToTac(CCodeBlock *cb)$/;"	f	class:CAstFunctionCall
ToTac	src/ast.cpp	/^CTacAddr* CAstFunctionCall::ToTac(CCodeBlock *cb,$/;"	f	class:CAstFunctionCall
ToTac	src/ast.cpp	/^CTacAddr* CAstScope::ToTac(CCodeBlock *cb)$/;"	f	class:CAstScope
ToTac	src/ast.cpp	/^CTacAddr* CAstSpecialOp::ToTac(CCodeBlock *cb)$/;"	f	class:CAstSpecialOp
ToTac	src/ast.cpp	/^CTacAddr* CAstStatAssign::ToTac(CCodeBlock *cb, CTacLabel *next)$/;"	f	class:CAstStatAssign
ToTac	src/ast.cpp	/^CTacAddr* CAstStatCall::ToTac(CCodeBlock *cb, CTacLabel *next)$/;"	f	class:CAstStatCall
ToTac	src/ast.cpp	/^CTacAddr* CAstStatIf::ToTac(CCodeBlock *cb, CTacLabel *next)$/;"	f	class:CAstStatIf
ToTac	src/ast.cpp	/^CTacAddr* CAstStatReturn::ToTac(CCodeBlock *cb, CTacLabel *next)$/;"	f	class:CAstStatReturn
ToTac	src/ast.cpp	/^CTacAddr* CAstStatWhile::ToTac(CCodeBlock *cb, CTacLabel *next)$/;"	f	class:CAstStatWhile
ToTac	src/ast.cpp	/^CTacAddr* CAstStatement::ToTac(CCodeBlock *cb, CTacLabel *next)$/;"	f	class:CAstStatement
ToTac	src/ast.cpp	/^CTacAddr* CAstStringConstant::ToTac(CCodeBlock *cb)$/;"	f	class:CAstStringConstant
ToTac	src/ast.cpp	/^CTacAddr* CAstStringConstant::ToTac(CCodeBlock *cb, CTacLabel *ltrue, CTacLabel *lfalse)$/;"	f	class:CAstStringConstant
ToTac	src/ast.cpp	/^CTacAddr* CAstUnaryOp::ToTac(CCodeBlock *cb)$/;"	f	class:CAstUnaryOp
ToTac	src/ast.cpp	/^CTacAddr* CAstUnaryOp::ToTac(CCodeBlock *cb, CTacLabel *ltrue, CTacLabel *lfalse)$/;"	f	class:CAstUnaryOp
TypeCheck	src/ast.cpp	/^bool CAstArrayDesignator::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstArrayDesignator
TypeCheck	src/ast.cpp	/^bool CAstBinaryOp::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstBinaryOp
TypeCheck	src/ast.cpp	/^bool CAstConstant::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstConstant
TypeCheck	src/ast.cpp	/^bool CAstDesignator::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstDesignator
TypeCheck	src/ast.cpp	/^bool CAstFunctionCall::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstFunctionCall
TypeCheck	src/ast.cpp	/^bool CAstScope::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstScope
TypeCheck	src/ast.cpp	/^bool CAstSpecialOp::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstSpecialOp
TypeCheck	src/ast.cpp	/^bool CAstStatAssign::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstStatAssign
TypeCheck	src/ast.cpp	/^bool CAstStatCall::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstStatCall
TypeCheck	src/ast.cpp	/^bool CAstStatIf::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstStatIf
TypeCheck	src/ast.cpp	/^bool CAstStatReturn::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstStatReturn
TypeCheck	src/ast.cpp	/^bool CAstStatWhile::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstStatWhile
TypeCheck	src/ast.cpp	/^bool CAstStringConstant::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstStringConstant
TypeCheck	src/ast.cpp	/^bool CAstUnaryOp::TypeCheck(CToken *t, string *msg) const$/;"	f	class:CAstUnaryOp
__SnuPL1_SCANNER_H__	src/scanner.h	37;"	d
__SnuPL_AST_H__	src/ast.h	37;"	d
__SnuPL_BACKEND_H__	src/backend.h	36;"	d
__SnuPL_DATA_H__	src/data.h	34;"	d
__SnuPL_IR_H__	src/ir.h	38;"	d
__SnuPL_PARSER_H__	src/parser.h	37;"	d
__SnuPL_SYMTAB_H__	src/symtab.h	34;"	d
__SnuPL_TYPE_H__	src/type.h	35;"	d
_abort	src/parser.h	/^		bool          _abort;         \/\/\/< error flag$/;"	m	class:CParser
_addr	src/ast.h	/^		CTacAddr   *_addr;              \/\/\/< result of this node in three-address$/;"	m	class:CAstNode
_arg	src/ast.h	/^		vector<CAstExpression*> _arg;   \/\/\/< parameter list$/;"	m	class:CAstFunctionCall
_array	src/type.h	/^    vector<CArrayType*> _array;   \/\/\/< array types$/;"	m	class:CTypeManager
_ast	src/ir.h	/^    CAstNode *_ast;                  \/\/\/< abstract syntax tree$/;"	m	class:CScope
_basetype	src/type.h	/^    const CType   *_basetype;     \/\/\/< base type$/;"	m	class:CPointerType
_body	src/ast.h	/^		CAstStatement *_body;           \/\/\/< body$/;"	m	class:CAstStatWhile
_boolean	src/type.h	/^    CBoolType     *_boolean;      \/\/\/< boolean base type$/;"	m	class:CTypeManager
_call	src/ast.h	/^		CAstFunctionCall *_call;        \/\/\/< call expression$/;"	m	class:CAstStatCall
_cb	src/ast.h	/^		CCodeBlock *_cb;                \/\/\/< (entry) code block for this scope$/;"	m	class:CAstScope
_cb	src/ir.h	/^    CCodeBlock* _cb;                 \/\/\/< list of code blocks$/;"	m	class:CScope
_char	src/scanner.h	/^    int     _char;                  \/\/\/< current stream position (character pos)$/;"	m	class:CScanner
_char	src/scanner.h	/^  int    _char;                   \/\/\/< input stream position (character pos)$/;"	m	class:CToken
_char	src/type.h	/^    CCharType     *_char;         \/\/\/< char base type$/;"	m	class:CTypeManager
_children	src/ast.h	/^		vector<CAstScope*> _children;   \/\/\/< subordinate scopes$/;"	m	class:CAstScope
_children	src/ir.h	/^    vector<CScope*> _children;       \/\/\/< list of functions$/;"	m	class:CScope
_cond	src/ast.h	/^		CAstExpression *_cond;          \/\/\/< condition$/;"	m	class:CAstStatIf
_cond	src/ast.h	/^		CAstExpression *_cond;          \/\/\/< condition$/;"	m	class:CAstStatWhile
_curr_scope	src/backend.h	/^    CScope *_curr_scope;            \/\/\/< current scope$/;"	m	class:CBackendx86
_data	src/data.h	/^    const string   _data;         \/\/\/< string data$/;"	m	class:CDataInitString
_data	src/symtab.h	/^    const CDataInitializer *_data;\/\/\/< data initializer$/;"	m	class:CSymbol
_datatype	src/symtab.h	/^    const CType   *_datatype;     \/\/\/< data type$/;"	m	class:CSymbol
_delete_in	src/scanner.h	/^    bool    _delete_in;             \/\/\/< delete input stream upon destruction$/;"	m	class:CScanner
_done	src/ast.h	/^		bool _done;                     \/\/\/< flag indicating all index expressions$/;"	m	class:CAstArrayDesignator
_dst	src/ir.h	/^    CTac          *_dst;             \/\/\/< destination operand$/;"	m	class:CTacInstr
_elseBody	src/ast.h	/^		CAstStatement *_elseBody;       \/\/\/< else body$/;"	m	class:CAstStatIf
_error_token	src/parser.h	/^		CToken        _error_token;   \/\/\/< error token$/;"	m	class:CParser
_expr	src/ast.h	/^		CAstExpression *_expr;          \/\/\/< return expression$/;"	m	class:CAstStatReturn
_global_id	src/ast.cpp	/^int CAstNode::_global_id = 0;$/;"	m	class:CAstNode	file:
_global_id	src/ast.h	/^		static int _global_id;          \/\/\/< holds the (global) next id$/;"	m	class:CAstNode
_global_tm	src/type.cpp	/^CTypeManager* CTypeManager::_global_tm = NULL;$/;"	m	class:CTypeManager	file:
_global_tm	src/type.h	/^    static CTypeManager *_global_tm; \/\/\/< global type manager instance$/;"	m	class:CTypeManager
_good	src/scanner.h	/^    bool    _good;                  \/\/\/< scanner status flag$/;"	m	class:CScanner
_id	src/ast.h	/^		int        _id;                 \/\/\/< id of the node$/;"	m	class:CAstNode
_id	src/ir.h	/^    unsigned int   _id;              \/\/\/< unique instruction id$/;"	m	class:CTacInstr
_idx	src/ast.cpp	/^int CAstStringConstant::_idx = 0;$/;"	m	class:CAstStringConstant	file:
_idx	src/ast.h	/^		static int       _idx;          \/\/\/< static counter$/;"	m	class:CAstStringConstant
_idx	src/ast.h	/^		vector<CAstExpression*> _idx;   \/\/\/< index expressions$/;"	m	class:CAstArrayDesignator
_ifBody	src/ast.h	/^		CAstStatement *_ifBody;         \/\/\/< if body$/;"	m	class:CAstStatIf
_in	src/scanner.h	/^    istream *_in;                   \/\/\/< input stream$/;"	m	class:CScanner
_ind	src/backend.h	/^    string _ind;                    \/\/\/< indentation$/;"	m	class:CBackendx86
_index	src/symtab.h	/^    int            _index;        \/\/\/< index$/;"	m	class:CSymParam
_innertype	src/type.h	/^    const CType   *_innertype;    \/\/\/< inner type$/;"	m	class:CArrayType
_inst_id	src/ir.h	/^    unsigned int _inst_id;           \/\/\/< next id for instructions$/;"	m	class:CCodeBlock
_integer	src/type.h	/^    CIntType      *_integer;      \/\/\/< integer base type$/;"	m	class:CTypeManager
_label	src/ir.h	/^    const string _label;             \/\/\/< label$/;"	m	class:CTacLabel
_label_id	src/ir.h	/^    unsigned int _label_id;          \/\/\/< next id for labels$/;"	m	class:CScope
_left	src/ast.h	/^		CAstExpression *_left;          \/\/\/< left operand$/;"	m	class:CAstBinaryOp
_lhs	src/ast.h	/^		CAstDesignator *_lhs;           \/\/\/< LHS (designator)$/;"	m	class:CAstStatAssign
_line	src/scanner.h	/^    int     _line;                  \/\/\/< current stream position (line)$/;"	m	class:CScanner
_line	src/scanner.h	/^  int    _line;                   \/\/\/< input stream position (line)$/;"	m	class:CToken
_m	src/backend.h	/^    CModule *_m;                    \/\/\/< module$/;"	m	class:CBackend
_message	src/parser.h	/^		string        _message;       \/\/\/< error message$/;"	m	class:CParser
_module	src/parser.h	/^		CAstModule   *_module;        \/\/\/< root node of the program$/;"	m	class:CParser
_name	src/ast.h	/^		string    _name;                \/\/\/< name$/;"	m	class:CAstScope
_name	src/ir.h	/^    string         _name;            \/\/\/< name (for debugging purposes)$/;"	m	class:CTacInstr
_name	src/ir.h	/^    string _name;                    \/\/\/< name$/;"	m	class:CScope
_name	src/symtab.h	/^    string         _name;         \/\/\/< name$/;"	m	class:CSymbol
_nelem	src/type.h	/^    int            _nelem;        \/\/\/< element count$/;"	m	class:CArrayType
_next	src/ast.h	/^		CAstStatement* _next;           \/\/\/< next statement$/;"	m	class:CAstStatement
_null	src/type.h	/^    CNullType     *_null;         \/\/\/< null base type$/;"	m	class:CTypeManager
_offset	src/ast.h	/^		CAstExpression *_offset;        \/\/\/< address computation expression$/;"	m	class:CAstArrayDesignator
_offset	src/symtab.h	/^    int            _offset;       \/\/\/< offset$/;"	m	class:CSymbol
_op	src/ir.h	/^    EOperation     _op;              \/\/\/< opcode$/;"	m	class:CTacInstr
_oper	src/ast.h	/^		EOperation _oper;               \/\/\/< operation$/;"	m	class:CAstOperation
_operand	src/ast.h	/^		CAstExpression *_operand;       \/\/\/< operand$/;"	m	class:CAstSpecialOp
_operand	src/ast.h	/^		CAstExpression *_operand;       \/\/\/< operand$/;"	m	class:CAstUnaryOp
_ops	src/ir.h	/^    list<CTacInstr*> _ops;           \/\/\/< operation list$/;"	m	class:CCodeBlock
_out	src/backend.h	/^    ostream &_out;                  \/\/\/< output stream$/;"	m	class:CBackend
_owner	src/ir.h	/^    CScope *_owner;                  \/\/\/< block owner$/;"	m	class:CCodeBlock
_param	src/symtab.h	/^    vector<CSymParam*> _param;      \/\/\/< parameter list$/;"	m	class:CSymProc
_parent	src/ast.h	/^		CAstScope *_parent;             \/\/\/< superordinate scope$/;"	m	class:CAstScope
_parent	src/ir.h	/^    CScope *_parent;                 \/\/\/< superordinate scope$/;"	m	class:CScope
_parent	src/symtab.h	/^    CSymtab       *_parent;       \/\/\/< parent$/;"	m	class:CSymtab
_ptr	src/type.h	/^    vector<CPointerType*> _ptr;   \/\/\/< pointer types$/;"	m	class:CTypeManager
_rbase	src/symtab.h	/^    string         _rbase;        \/\/\/< base register$/;"	m	class:CSymbol
_refcnt	src/ir.h	/^    int _refcnt;                     \/\/\/< reference counter$/;"	m	class:CTacLabel
_rhs	src/ast.h	/^		CAstExpression *_rhs;           \/\/\/< RHS (expression)$/;"	m	class:CAstStatAssign
_right	src/ast.h	/^		CAstExpression *_right;         \/\/\/< right operand$/;"	m	class:CAstBinaryOp
_saved_char	src/scanner.h	/^    int     _saved_char;            \/\/\/< saved stream position (character pos)$/;"	m	class:CScanner
_saved_line	src/scanner.h	/^    int     _saved_line;            \/\/\/< saved stream position (line)$/;"	m	class:CScanner
_scanner	src/parser.h	/^		CScanner     *_scanner;       \/\/\/< CScanner instance$/;"	m	class:CParser
_scope	src/ast.h	/^		CAstScope      *_scope;         \/\/\/< enclosing scope$/;"	m	class:CAstStatReturn
_src1	src/ir.h	/^    CTacAddr      *_src1;            \/\/\/< source operand 1$/;"	m	class:CTacInstr
_src2	src/ir.h	/^    CTacAddr      *_src2;            \/\/\/< source operand 2$/;"	m	class:CTacInstr
_statseq	src/ast.h	/^		CAstStatement* _statseq;        \/\/\/< statement sequence$/;"	m	class:CAstScope
_sym	src/ast.h	/^		CSymGlobal      *_sym;          \/\/\/< symbol holding the string$/;"	m	class:CAstStringConstant
_symbol	src/ast.h	/^		CSymProc *_symbol;              \/\/\/< corresponding symbol$/;"	m	class:CAstProcedure
_symbol	src/ast.h	/^		const CSymProc *_symbol;        \/\/\/< symbol$/;"	m	class:CAstFunctionCall
_symbol	src/ast.h	/^		const CSymbol *_symbol;         \/\/\/< symbol$/;"	m	class:CAstDesignator
_symbol	src/ir.h	/^    const CSymbol *_symbol;          \/\/\/< symbol$/;"	m	class:CTacName
_symboltype	src/symtab.h	/^    ESymbolType    _symboltype;   \/\/\/< symbol type$/;"	m	class:CSymbol
_symtab	src/ast.h	/^		CSymtab   *_symtab;             \/\/\/< symbol table$/;"	m	class:CAstScope
_symtab	src/ir.h	/^    CSymtab *_symtab;                \/\/\/< symbol table$/;"	m	class:CScope
_symtab	src/symtab.h	/^    CSymtab       *_symtab;       \/\/\/< symbol table owning this symbol$/;"	m	class:CSymbol
_symtab	src/symtab.h	/^    map<string, CSymbol*> _symtab;\/\/\/< local symbol table$/;"	m	class:CSymtab
_temp_id	src/ir.h	/^    unsigned int _temp_id;           \/\/\/< next id for temporaries$/;"	m	class:CScope
_token	src/ast.h	/^		CToken     _token;              \/\/\/< token in input stream that triggered$/;"	m	class:CAstNode
_token	src/parser.h	/^		CToken        _token;         \/\/\/< current token$/;"	m	class:CParser
_token	src/scanner.h	/^    CToken *_token;                 \/\/\/< next token in input stream$/;"	m	class:CScanner
_type	src/ast.h	/^		const CType     *_type;         \/\/\/< constant type$/;"	m	class:CAstStringConstant
_type	src/ast.h	/^		const CType *_type;             \/\/\/< constant type$/;"	m	class:CAstConstant
_type	src/ast.h	/^		const CType *_type;             \/\/\/< forced type of this op$/;"	m	class:CAstSpecialOp
_type	src/ast.h	/^		const CType *_type;             \/\/\/< type$/;"	m	class:CAstType
_type	src/scanner.h	/^  EToken _type;                   \/\/\/< token type$/;"	m	class:CToken
_value	src/ast.h	/^		CDataInitString *_value;        \/\/\/< data initializer (holds string data)$/;"	m	class:CAstStringConstant
_value	src/ast.h	/^		long long _value;               \/\/\/< constant value$/;"	m	class:CAstConstant
_value	src/ir.h	/^    int _value;                      \/\/\/< constant value$/;"	m	class:CTacConst
_value	src/scanner.h	/^  string _value;                  \/\/\/< token value$/;"	m	class:CToken
_voidptr	src/type.h	/^    CPointerType  *_voidptr;      \/\/\/< void pointer type$/;"	m	class:CTypeManager
a	mytest.mod.s	/^a:                                  # <int>$/;"	l
assignment	src/parser.cpp	/^CAstStatAssign* CParser::assignment(CAstScope *s)$/;"	f	class:CParser
boolean	src/parser.cpp	/^CAstConstant* CParser::boolean(void)$/;"	f	class:CParser
character	src/parser.cpp	/^CAstConstant* CParser::character()$/;"	f	class:CParser
dotAttr	src/ast.cpp	/^string CAstArrayDesignator::dotAttr(void) const$/;"	f	class:CAstArrayDesignator
dotAttr	src/ast.cpp	/^string CAstBinaryOp::dotAttr(void) const$/;"	f	class:CAstBinaryOp
dotAttr	src/ast.cpp	/^string CAstConstant::dotAttr(void) const$/;"	f	class:CAstConstant
dotAttr	src/ast.cpp	/^string CAstDesignator::dotAttr(void) const$/;"	f	class:CAstDesignator
dotAttr	src/ast.cpp	/^string CAstFunctionCall::dotAttr(void) const$/;"	f	class:CAstFunctionCall
dotAttr	src/ast.cpp	/^string CAstModule::dotAttr(void) const$/;"	f	class:CAstModule
dotAttr	src/ast.cpp	/^string CAstNode::dotAttr(void) const$/;"	f	class:CAstNode
dotAttr	src/ast.cpp	/^string CAstProcedure::dotAttr(void) const$/;"	f	class:CAstProcedure
dotAttr	src/ast.cpp	/^string CAstSpecialOp::dotAttr(void) const$/;"	f	class:CAstSpecialOp
dotAttr	src/ast.cpp	/^string CAstStatAssign::dotAttr(void) const$/;"	f	class:CAstStatAssign
dotAttr	src/ast.cpp	/^string CAstStatCall::dotAttr(void) const$/;"	f	class:CAstStatCall
dotAttr	src/ast.cpp	/^string CAstStatIf::dotAttr(void) const$/;"	f	class:CAstStatIf
dotAttr	src/ast.cpp	/^string CAstStatReturn::dotAttr(void) const$/;"	f	class:CAstStatReturn
dotAttr	src/ast.cpp	/^string CAstStatWhile::dotAttr(void) const$/;"	f	class:CAstStatWhile
dotAttr	src/ast.cpp	/^string CAstStringConstant::dotAttr(void) const$/;"	f	class:CAstStringConstant
dotAttr	src/ast.cpp	/^string CAstUnaryOp::dotAttr(void) const$/;"	f	class:CAstUnaryOp
dotAttr	src/ir.cpp	/^string CCodeBlock::dotAttr(void) const$/;"	f	class:CCodeBlock
dotID	src/ast.cpp	/^string CAstNode::dotID(void) const$/;"	f	class:CAstNode
dotID	src/ast.cpp	/^string CAstStatCall::dotID(void) const$/;"	f	class:CAstStatCall
dotID	src/ir.cpp	/^string CCodeBlock::dotID(void) const$/;"	f	class:CCodeBlock
dotID	src/ir.cpp	/^string CScope::dotID(void) const$/;"	f	class:CScope
dump_asm	src/snuplc.cpp	/^bool dump_asm = true;$/;"	v
dump_dot	src/snuplc.cpp	/^bool dump_dot = true;$/;"	v
dump_tac	src/snuplc.cpp	/^bool dump_tac = false;$/;"	v
escape	src/scanner.cpp	/^string CToken::escape(const string text)$/;"	f	class:CToken
expression	src/parser.cpp	/^CAstExpression* CParser::expression(CAstScope* s)$/;"	f	class:CParser
factor	src/parser.cpp	/^CAstExpression* CParser::factor(CAstScope *s)$/;"	f	class:CParser
files	src/snuplc.cpp	/^vector<string> files;$/;"	v
ifstatement	src/parser.cpp	/^CAstStatement* CParser::ifstatement(CAstScope *s)$/;"	f	class:CParser
keywords	src/scanner.cpp	/^map<string, EToken> CScanner::keywords;$/;"	m	class:CScanner	file:
keywords	src/scanner.h	/^    static map<string, EToken> keywords;\/\/\/< reserved keywords with corr. tokens$/;"	m	class:CScanner
l_mytest_exit	mytest.mod.s	/^l_mytest_exit:$/;"	l
main	mytest.mod.s	/^main:$/;"	l
main	src/snuplc.cpp	/^int main(int argc, char *argv[])$/;"	f
main	src/test_ir.cpp	/^int main(int argc, char *argv[])$/;"	f
main	src/test_parser.cpp	/^int main(int argc, char *argv[])$/;"	f
main	src/test_scanner.cpp	/^int main(int argc, char *argv[])$/;"	f
module	src/parser.cpp	/^CAstModule* CParser::module(void)$/;"	f	class:CParser
number	src/parser.cpp	/^CAstConstant* CParser::number(bool pos)$/;"	f	class:CParser
opAdd	src/ir.h	/^  opAdd=0,                          \/\/\/< +  addition$/;"	e	enum:EOperation
opAddress	src/ir.h	/^  opAddress,                        \/\/\/< reference: dst = &src1$/;"	e	enum:EOperation
opAnd	src/ir.h	/^  opAnd,                            \/\/\/< && binary and$/;"	e	enum:EOperation
opAssign	src/ir.h	/^  opAssign,                         \/\/\/< assignment$/;"	e	enum:EOperation
opBiggerEqual	src/ir.h	/^  opBiggerEqual,                    \/\/\/< >= bigger or equal$/;"	e	enum:EOperation
opBiggerThan	src/ir.h	/^  opBiggerThan,                     \/\/\/< >  bigger than$/;"	e	enum:EOperation
opCall	src/ir.h	/^  opCall,                           \/\/\/< call:  dst = call src1$/;"	e	enum:EOperation
opCast	src/ir.h	/^  opCast,                           \/\/\/< type cast: dst = (type)src1$/;"	e	enum:EOperation
opDeref	src/ir.h	/^  opDeref,                          \/\/\/< dereference: dst = *src1$/;"	e	enum:EOperation
opDiv	src/ir.h	/^  opDiv,                            \/\/\/< \/  division$/;"	e	enum:EOperation
opEqual	src/ir.h	/^  opEqual,                          \/\/\/< =  equal$/;"	e	enum:EOperation
opGoto	src/ir.h	/^  opGoto,                           \/\/\/< dst = target$/;"	e	enum:EOperation
opLabel	src/ir.h	/^  opLabel,                          \/\/\/< jump label; no arguments$/;"	e	enum:EOperation
opLessEqual	src/ir.h	/^  opLessEqual,                      \/\/\/< <= less or equal$/;"	e	enum:EOperation
opLessThan	src/ir.h	/^  opLessThan,                       \/\/\/< <  less than$/;"	e	enum:EOperation
opMul	src/ir.h	/^  opMul,                            \/\/\/< *  multiplication$/;"	e	enum:EOperation
opNeg	src/ir.h	/^  opNeg,                            \/\/\/< -  negation$/;"	e	enum:EOperation
opNop	src/ir.h	/^  opNop,                            \/\/\/< no operation$/;"	e	enum:EOperation
opNot	src/ir.h	/^  opNot,                            \/\/\/< !  binary not$/;"	e	enum:EOperation
opNotEqual	src/ir.h	/^  opNotEqual,                       \/\/\/< #  not equal$/;"	e	enum:EOperation
opOr	src/ir.h	/^  opOr,                             \/\/\/< || binary or$/;"	e	enum:EOperation
opParam	src/ir.h	/^  opParam,                          \/\/\/< parameter: dst = index,src1 = parameter$/;"	e	enum:EOperation
opPos	src/ir.h	/^  opPos,                            \/\/\/< +  unary +$/;"	e	enum:EOperation
opReturn	src/ir.h	/^  opReturn,                         \/\/\/< return: return optional src1$/;"	e	enum:EOperation
opSub	src/ir.h	/^  opSub,                            \/\/\/< -  subtraction$/;"	e	enum:EOperation
operator <<	src/ast.cpp	/^ostream& operator<<(ostream &out, const CAstNode &t)$/;"	f
operator <<	src/ast.cpp	/^ostream& operator<<(ostream &out, const CAstNode *t)$/;"	f
operator <<	src/data.cpp	/^ostream& operator<<(ostream &out, const CDataInitializer &t)$/;"	f
operator <<	src/data.cpp	/^ostream& operator<<(ostream &out, const CDataInitializer *t)$/;"	f
operator <<	src/ir.cpp	/^ostream& operator<<(ostream &out, EOperation t)$/;"	f
operator <<	src/ir.cpp	/^ostream& operator<<(ostream &out, const CCodeBlock &t)$/;"	f
operator <<	src/ir.cpp	/^ostream& operator<<(ostream &out, const CCodeBlock *t)$/;"	f
operator <<	src/ir.cpp	/^ostream& operator<<(ostream &out, const CScope &t)$/;"	f
operator <<	src/ir.cpp	/^ostream& operator<<(ostream &out, const CScope *t)$/;"	f
operator <<	src/ir.cpp	/^ostream& operator<<(ostream &out, const CTac &t)$/;"	f
operator <<	src/ir.cpp	/^ostream& operator<<(ostream &out, const CTac *t)$/;"	f
operator <<	src/scanner.cpp	/^ostream& operator<<(ostream &out, const CToken &t)$/;"	f
operator <<	src/scanner.cpp	/^ostream& operator<<(ostream &out, const CToken *t)$/;"	f
operator <<	src/symtab.cpp	/^ostream& operator<<(ostream &out, const CSymbol &t)$/;"	f
operator <<	src/symtab.cpp	/^ostream& operator<<(ostream &out, const CSymbol *t)$/;"	f
operator <<	src/symtab.cpp	/^ostream& operator<<(ostream &out, const CSymtab &t)$/;"	f
operator <<	src/symtab.cpp	/^ostream& operator<<(ostream &out, const CSymtab *t)$/;"	f
operator <<	src/type.cpp	/^ostream& operator<<(ostream &out, const CType &t)$/;"	f
operator <<	src/type.cpp	/^ostream& operator<<(ostream &out, const CType *t)$/;"	f
print	src/ast.cpp	/^ostream& CAstArrayDesignator::print(ostream &out, int indent) const$/;"	f	class:CAstArrayDesignator
print	src/ast.cpp	/^ostream& CAstBinaryOp::print(ostream &out, int indent) const$/;"	f	class:CAstBinaryOp
print	src/ast.cpp	/^ostream& CAstConstant::print(ostream &out, int indent) const$/;"	f	class:CAstConstant
print	src/ast.cpp	/^ostream& CAstDesignator::print(ostream &out, int indent) const$/;"	f	class:CAstDesignator
print	src/ast.cpp	/^ostream& CAstFunctionCall::print(ostream &out, int indent) const$/;"	f	class:CAstFunctionCall
print	src/ast.cpp	/^ostream& CAstScope::print(ostream &out, int indent) const$/;"	f	class:CAstScope
print	src/ast.cpp	/^ostream& CAstSpecialOp::print(ostream &out, int indent) const$/;"	f	class:CAstSpecialOp
print	src/ast.cpp	/^ostream& CAstStatAssign::print(ostream &out, int indent) const$/;"	f	class:CAstStatAssign
print	src/ast.cpp	/^ostream& CAstStatCall::print(ostream &out, int indent) const$/;"	f	class:CAstStatCall
print	src/ast.cpp	/^ostream& CAstStatIf::print(ostream &out, int indent) const$/;"	f	class:CAstStatIf
print	src/ast.cpp	/^ostream& CAstStatReturn::print(ostream &out, int indent) const$/;"	f	class:CAstStatReturn
print	src/ast.cpp	/^ostream& CAstStatWhile::print(ostream &out, int indent) const$/;"	f	class:CAstStatWhile
print	src/ast.cpp	/^ostream& CAstStringConstant::print(ostream &out, int indent) const$/;"	f	class:CAstStringConstant
print	src/ast.cpp	/^ostream& CAstType::print(ostream &out, int indent) const$/;"	f	class:CAstType
print	src/ast.cpp	/^ostream& CAstUnaryOp::print(ostream &out, int indent) const$/;"	f	class:CAstUnaryOp
print	src/data.cpp	/^ostream& CDataInitString::print(ostream &out, int indent) const$/;"	f	class:CDataInitString
print	src/ir.cpp	/^ostream& CCodeBlock::print(ostream &out, int indent) const$/;"	f	class:CCodeBlock
print	src/ir.cpp	/^ostream& CModule::print(ostream &out, int indent) const$/;"	f	class:CModule
print	src/ir.cpp	/^ostream& CProcedure::print(ostream &out, int indent) const$/;"	f	class:CProcedure
print	src/ir.cpp	/^ostream& CScope::print(ostream &out, int indent) const$/;"	f	class:CScope
print	src/ir.cpp	/^ostream& CTacConst::print(ostream &out, int indent) const$/;"	f	class:CTacConst
print	src/ir.cpp	/^ostream& CTacInstr::print(ostream &out, int indent) const$/;"	f	class:CTacInstr
print	src/ir.cpp	/^ostream& CTacLabel::print(ostream &out, int indent) const$/;"	f	class:CTacLabel
print	src/ir.cpp	/^ostream& CTacName::print(ostream &out, int indent) const$/;"	f	class:CTacName
print	src/ir.cpp	/^ostream& CTacReference::print(ostream &out, int indent) const$/;"	f	class:CTacReference
print	src/scanner.cpp	/^ostream& CToken::print(ostream &out) const$/;"	f	class:CToken
print	src/symtab.cpp	/^ostream& CSymGlobal::print(ostream &out, int indent) const$/;"	f	class:CSymGlobal
print	src/symtab.cpp	/^ostream& CSymLocal::print(ostream &out, int indent) const$/;"	f	class:CSymLocal
print	src/symtab.cpp	/^ostream& CSymParam::print(ostream &out, int indent) const$/;"	f	class:CSymParam
print	src/symtab.cpp	/^ostream& CSymProc::print(ostream &out, int indent) const$/;"	f	class:CSymProc
print	src/symtab.cpp	/^ostream& CSymbol::print(ostream &out, int indent) const$/;"	f	class:CSymbol
print	src/symtab.cpp	/^ostream& CSymtab::print(ostream &out, int indent) const$/;"	f	class:CSymtab
print	src/type.cpp	/^ostream& CArrayType::print(ostream &out, int indent) const$/;"	f	class:CArrayType
print	src/type.cpp	/^ostream& CBoolType::print(ostream &out, int indent) const$/;"	f	class:CBoolType
print	src/type.cpp	/^ostream& CCharType::print(ostream &out, int indent) const$/;"	f	class:CCharType
print	src/type.cpp	/^ostream& CIntType::print(ostream &out, int indent) const$/;"	f	class:CIntType
print	src/type.cpp	/^ostream& CNullType::print(ostream &out, int indent) const$/;"	f	class:CNullType
print	src/type.cpp	/^ostream& CPointerType::print(ostream &out, int indent) const$/;"	f	class:CPointerType
print	src/type.cpp	/^ostream& CTypeManager::print(ostream &out, int indent) const$/;"	f	class:CTypeManager
qualident	src/parser.cpp	/^CAstArrayDesignator* CParser::qualident(CAstScope *s)$/;"	f	class:CParser
returnstatement	src/parser.cpp	/^CAstStatement* CParser::returnstatement(CAstScope *s)$/;"	f	class:CParser
rte_path	src/snuplc.cpp	/^string rte_path = "rte\/IA32\/";$/;"	v
run_dot	src/snuplc.cpp	/^bool run_dot  = true;$/;"	v
run_gcc	src/snuplc.cpp	/^bool run_gcc  = false;$/;"	v
sGlobal	src/symtab.h	/^  sGlobal,                        \/\/\/< global$/;"	e	enum:EScope
sLocal	src/symtab.h	/^  sLocal,                         \/\/\/< local$/;"	e	enum:EScope
simpleexpr	src/parser.cpp	/^CAstExpression* CParser::simpleexpr(CAstScope *s)$/;"	f	class:CParser
stGlobal	src/symtab.h	/^  stGlobal,         \/\/\/< global symbol$/;"	e	enum:ESymbolType
stLocal	src/symtab.h	/^  stLocal,          \/\/\/< local symbol$/;"	e	enum:ESymbolType
stParam	src/symtab.h	/^  stParam,          \/\/\/< parameter symbol$/;"	e	enum:ESymbolType
stProcedure	src/symtab.h	/^  stProcedure,      \/\/\/< procedure symbol$/;"	e	enum:ESymbolType
statSequence	src/parser.cpp	/^CAstStatement* CParser::statSequence(CAstScope *s)$/;"	f	class:CParser
subroutinebody	src/parser.cpp	/^CAstExpression* CParser::subroutinebody(CAstScope *s)$/;"	f	class:CParser
subroutinecall	src/parser.cpp	/^CAstStatCall* CParser::subroutinecall(CAstScope *s)$/;"	f	class:CParser
subroutinedecl	src/parser.cpp	/^CAstProcedure* CParser::subroutinedecl(CAstScope *s)$/;"	f	class:CParser
tAssign	src/scanner.h	/^  tAssign,						\/\/\/< assignment operator$/;"	e	enum:EToken
tBegin	src/scanner.h	/^  tBegin,							\/\/\/< keyword "begin"$/;"	e	enum:EToken
tBoolean	src/scanner.h	/^  tBoolean,						\/\/\/< keyword "boolean"$/;"	e	enum:EToken
tChar	src/scanner.h	/^  tChar,							\/\/\/< keyword "char"$/;"	e	enum:EToken
tCharacter	src/scanner.h	/^  tCharacter,						\/\/\/< a char such as 'a'$/;"	e	enum:EToken
tColon	src/scanner.h	/^  tColon,							\/\/\/< a colon$/;"	e	enum:EToken
tComma	src/scanner.h	/^  tComma, 						\/\/\/< a comma$/;"	e	enum:EToken
tDo	src/scanner.h	/^  tDo,							\/\/\/< keyword "do"$/;"	e	enum:EToken
tDot	src/scanner.h	/^  tDot,                           \/\/\/< a dot$/;"	e	enum:EToken
tEOF	src/scanner.h	/^  tEOF,                           \/\/\/< end of file$/;"	e	enum:EToken
tElse	src/scanner.h	/^  tElse,							\/\/\/< keyword "else"$/;"	e	enum:EToken
tEnd	src/scanner.h	/^  tEnd,							\/\/\/< keyword "end"$/;"	e	enum:EToken
tFactOp	src/scanner.h	/^  tFactOp,						\/\/\/< '*' or '\/' or '&&'$/;"	e	enum:EToken
tFalse	src/scanner.h	/^  tFalse,							\/\/\/< keyword "false"$/;"	e	enum:EToken
tFunction	src/scanner.h	/^  tFunction,						\/\/\/< keyword "function"$/;"	e	enum:EToken
tIOError	src/scanner.h	/^  tIOError,                       \/\/\/< I\/O error$/;"	e	enum:EToken
tIdent	src/scanner.h	/^  tIdent,                         \/\/\/< a ident$/;"	e	enum:EToken
tIf	src/scanner.h	/^  tIf,							\/\/\/< keyword "if"$/;"	e	enum:EToken
tInteger	src/scanner.h	/^  tInteger,						\/\/\/< keyword "integer"	$/;"	e	enum:EToken
tLBrak	src/scanner.h	/^  tLBrak,                         \/\/\/< a left bracket '('$/;"	e	enum:EToken
tLLBrak	src/scanner.h	/^  tLLBrak,						\/\/\/< a left square bracket '['$/;"	e	enum:EToken
tModule	src/scanner.h	/^  tModule,						\/\/\/< keyword "module"$/;"	e	enum:EToken
tNot	src/scanner.h	/^  tNot, 							\/\/\/< '!'$/;"	e	enum:EToken
tNumber	src/scanner.h	/^  tNumber=0,                      \/\/\/< a number$/;"	e	enum:EToken
tProcedure	src/scanner.h	/^  tProcedure,						\/\/\/< keyword "module"$/;"	e	enum:EToken
tRBrak	src/scanner.h	/^  tRBrak,                         \/\/\/< a right bracket ')'$/;"	e	enum:EToken
tRRBrak	src/scanner.h	/^  tRRBrak,						\/\/\/< a right square bracket ']' $/;"	e	enum:EToken
tRelOp	src/scanner.h	/^  tRelOp,                         \/\/\/< relational operator$/;"	e	enum:EToken
tReturn	src/scanner.h	/^  tReturn,						\/\/\/< keyword "return"$/;"	e	enum:EToken
tSemicolon	src/scanner.h	/^  tSemicolon,                     \/\/\/< a semicolon$/;"	e	enum:EToken
tString	src/scanner.h	/^  tString,						\/\/\/< a string such as "Hello"$/;"	e	enum:EToken
tTermOp	src/scanner.h	/^  tTermOp,						\/\/\/< '+' or '-' or '||'$/;"	e	enum:EToken
tThen	src/scanner.h	/^  tThen,							\/\/\/< keyword "then"$/;"	e	enum:EToken
tTrue	src/scanner.h	/^  tTrue,							\/\/\/< keyword "true"$/;"	e	enum:EToken
tUndefined	src/scanner.h	/^  tUndefined,                     \/\/\/< undefined$/;"	e	enum:EToken
tVar	src/scanner.h	/^  tVar,							\/\/\/< keyword "var"$/;"	e	enum:EToken
tWhile	src/scanner.h	/^  tWhile,							\/\/\/< keyword "while"$/;"	e	enum:EToken
term	src/parser.cpp	/^CAstExpression* CParser::term(CAstScope *s)$/;"	f	class:CParser
toDot	src/ast.cpp	/^void CAstArrayDesignator::toDot(ostream &out, int indent) const$/;"	f	class:CAstArrayDesignator
toDot	src/ast.cpp	/^void CAstBinaryOp::toDot(ostream &out, int indent) const$/;"	f	class:CAstBinaryOp
toDot	src/ast.cpp	/^void CAstDesignator::toDot(ostream &out, int indent) const$/;"	f	class:CAstDesignator
toDot	src/ast.cpp	/^void CAstFunctionCall::toDot(ostream &out, int indent) const$/;"	f	class:CAstFunctionCall
toDot	src/ast.cpp	/^void CAstNode::toDot(ostream &out, int indent) const$/;"	f	class:CAstNode
toDot	src/ast.cpp	/^void CAstScope::toDot(ostream &out, int indent) const$/;"	f	class:CAstScope
toDot	src/ast.cpp	/^void CAstSpecialOp::toDot(ostream &out, int indent) const$/;"	f	class:CAstSpecialOp
toDot	src/ast.cpp	/^void CAstStatAssign::toDot(ostream &out, int indent) const$/;"	f	class:CAstStatAssign
toDot	src/ast.cpp	/^void CAstStatCall::toDot(ostream &out, int indent) const$/;"	f	class:CAstStatCall
toDot	src/ast.cpp	/^void CAstStatIf::toDot(ostream &out, int indent) const$/;"	f	class:CAstStatIf
toDot	src/ast.cpp	/^void CAstStatReturn::toDot(ostream &out, int indent) const$/;"	f	class:CAstStatReturn
toDot	src/ast.cpp	/^void CAstStatWhile::toDot(ostream &out, int indent) const$/;"	f	class:CAstStatWhile
toDot	src/ast.cpp	/^void CAstUnaryOp::toDot(ostream &out, int indent) const$/;"	f	class:CAstUnaryOp
toDot	src/ir.cpp	/^void CCodeBlock::toDot(ostream &out, int indent) const$/;"	f	class:CCodeBlock
toDot	src/ir.cpp	/^void CScope::toDot(ostream &out, int indent) const$/;"	f	class:CScope
type	src/parser.cpp	/^CAstType* CParser::type(CAstScope *s, bool declare, bool pointer)$/;"	f	class:CParser
unescape	src/scanner.cpp	/^string CToken::unescape(const string text)$/;"	f	class:CToken
vardecl	src/parser.cpp	/^void CParser::vardecl(CAstScope *s)$/;"	f	class:CParser
vardeclaration	src/parser.cpp	/^void CParser::vardeclaration(CAstScope *s)$/;"	f	class:CParser
vardeclsequence	src/parser.cpp	/^void CParser::vardeclsequence(CAstScope *s)$/;"	f	class:CParser
whilestatement	src/parser.cpp	/^CAstStatement* CParser::whilestatement(CAstScope *s)$/;"	f	class:CParser
~CArrayType	src/type.cpp	/^CArrayType::~CArrayType(void)$/;"	f	class:CArrayType
~CAstNode	src/ast.cpp	/^CAstNode::~CAstNode(void)$/;"	f	class:CAstNode
~CAstScope	src/ast.cpp	/^CAstScope::~CAstScope(void)$/;"	f	class:CAstScope
~CAstStatement	src/ast.cpp	/^CAstStatement::~CAstStatement(void)$/;"	f	class:CAstStatement
~CBackend	src/backend.cpp	/^CBackend::~CBackend(void)$/;"	f	class:CBackend
~CBackendx86	src/backend.cpp	/^CBackendx86::~CBackendx86(void)$/;"	f	class:CBackendx86
~CCodeBlock	src/ir.cpp	/^CCodeBlock::~CCodeBlock(void)$/;"	f	class:CCodeBlock
~CDataInitializer	src/data.cpp	/^CDataInitializer::~CDataInitializer(void)$/;"	f	class:CDataInitializer
~CModule	src/ir.cpp	/^CModule::~CModule(void)$/;"	f	class:CModule
~CProcedure	src/ir.cpp	/^CProcedure::~CProcedure(void)$/;"	f	class:CProcedure
~CScanner	src/scanner.cpp	/^CScanner::~CScanner()$/;"	f	class:CScanner
~CScope	src/ir.cpp	/^CScope::~CScope(void)$/;"	f	class:CScope
~CSymbol	src/symtab.cpp	/^CSymbol::~CSymbol(void)$/;"	f	class:CSymbol
~CSymtab	src/symtab.cpp	/^CSymtab::~CSymtab(void)$/;"	f	class:CSymtab
~CTac	src/ir.cpp	/^CTac::~CTac(void)$/;"	f	class:CTac
~CTacAddr	src/ir.cpp	/^CTacAddr::~CTacAddr(void)$/;"	f	class:CTacAddr
~CTacInstr	src/ir.cpp	/^CTacInstr::~CTacInstr(void)$/;"	f	class:CTacInstr
~CTacLabel	src/ir.cpp	/^CTacLabel::~CTacLabel(void)$/;"	f	class:CTacLabel
~CType	src/type.cpp	/^CType::~CType(void)$/;"	f	class:CType
~CTypeManager	src/type.cpp	/^CTypeManager::~CTypeManager(void)$/;"	f	class:CTypeManager
